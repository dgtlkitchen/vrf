// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: digitalkitchen/vrf/v1/vrf.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VrfBeacon is the canonical drand beacon selected for a given block height.
// It carries only the fields required for full on-chain verification.
type VrfBeacon struct {
	// drand_round is the drand round number.
	DrandRound uint64 `protobuf:"varint,1,opt,name=drand_round,json=drandRound,proto3" json:"drand_round,omitempty"`
	// randomness is SHA256(signature).
	Randomness []byte `protobuf:"bytes,2,opt,name=randomness,proto3" json:"randomness,omitempty"`
	// signature is the drand BLS signature for this round.
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	// previous_signature is the BLS signature of the previous round, required
	// for chained-scheme verification.
	PreviousSignature []byte `protobuf:"bytes,4,opt,name=previous_signature,json=previousSignature,proto3" json:"previous_signature,omitempty"`
}

func (m *VrfBeacon) Reset()         { *m = VrfBeacon{} }
func (m *VrfBeacon) String() string { return proto.CompactTextString(m) }
func (*VrfBeacon) ProtoMessage()    {}
func (*VrfBeacon) Descriptor() ([]byte, []int) {
	return fileDescriptor_e758a8cd98a93fdd, []int{0}
}
func (m *VrfBeacon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VrfBeacon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VrfBeacon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VrfBeacon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VrfBeacon.Merge(m, src)
}
func (m *VrfBeacon) XXX_Size() int {
	return m.Size()
}
func (m *VrfBeacon) XXX_DiscardUnknown() {
	xxx_messageInfo_VrfBeacon.DiscardUnknown(m)
}

var xxx_messageInfo_VrfBeacon proto.InternalMessageInfo

func (m *VrfBeacon) GetDrandRound() uint64 {
	if m != nil {
		return m.DrandRound
	}
	return 0
}

func (m *VrfBeacon) GetRandomness() []byte {
	if m != nil {
		return m.Randomness
	}
	return nil
}

func (m *VrfBeacon) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *VrfBeacon) GetPreviousSignature() []byte {
	if m != nil {
		return m.PreviousSignature
	}
	return nil
}

// AllowlistEntry maps an address to a human-readable label for auditing.
type AllowlistEntry struct {
	// address is the allowlisted account address.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// label is free-form metadata for operator UX / auditing.
	Label string `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
}

func (m *AllowlistEntry) Reset()         { *m = AllowlistEntry{} }
func (m *AllowlistEntry) String() string { return proto.CompactTextString(m) }
func (*AllowlistEntry) ProtoMessage()    {}
func (*AllowlistEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_e758a8cd98a93fdd, []int{1}
}
func (m *AllowlistEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllowlistEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllowlistEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllowlistEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllowlistEntry.Merge(m, src)
}
func (m *AllowlistEntry) XXX_Size() int {
	return m.Size()
}
func (m *AllowlistEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AllowlistEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AllowlistEntry proto.InternalMessageInfo

func (m *AllowlistEntry) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AllowlistEntry) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

// VrfIdentity binds a validator to a drand BLS identity / share for monitoring
// and resharing coordination.
type VrfIdentity struct {
	// validator_address is the validator operator address.
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// drand_bls_public_key is the validator's drand BLS public key/share.
	DrandBlsPublicKey []byte `protobuf:"bytes,2,opt,name=drand_bls_public_key,json=drandBlsPublicKey,proto3" json:"drand_bls_public_key,omitempty"`
	// chain_hash is the drand chain hash this identity is bound to.
	ChainHash []byte `protobuf:"bytes,3,opt,name=chain_hash,json=chainHash,proto3" json:"chain_hash,omitempty"`
	// signal_unix_sec is the UNIX time when this identity was first registered.
	SignalUnixSec int64 `protobuf:"varint,4,opt,name=signal_unix_sec,json=signalUnixSec,proto3" json:"signal_unix_sec,omitempty"`
	// signal_reshare_epoch is the value of VrfParams.reshare_epoch when this
	// identity was first registered.
	SignalReshareEpoch uint64 `protobuf:"varint,5,opt,name=signal_reshare_epoch,json=signalReshareEpoch,proto3" json:"signal_reshare_epoch,omitempty"`
}

func (m *VrfIdentity) Reset()         { *m = VrfIdentity{} }
func (m *VrfIdentity) String() string { return proto.CompactTextString(m) }
func (*VrfIdentity) ProtoMessage()    {}
func (*VrfIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_e758a8cd98a93fdd, []int{2}
}
func (m *VrfIdentity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VrfIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VrfIdentity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VrfIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VrfIdentity.Merge(m, src)
}
func (m *VrfIdentity) XXX_Size() int {
	return m.Size()
}
func (m *VrfIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_VrfIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_VrfIdentity proto.InternalMessageInfo

func (m *VrfIdentity) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *VrfIdentity) GetDrandBlsPublicKey() []byte {
	if m != nil {
		return m.DrandBlsPublicKey
	}
	return nil
}

func (m *VrfIdentity) GetChainHash() []byte {
	if m != nil {
		return m.ChainHash
	}
	return nil
}

func (m *VrfIdentity) GetSignalUnixSec() int64 {
	if m != nil {
		return m.SignalUnixSec
	}
	return 0
}

func (m *VrfIdentity) GetSignalReshareEpoch() uint64 {
	if m != nil {
		return m.SignalReshareEpoch
	}
	return 0
}

func init() {
	proto.RegisterType((*VrfBeacon)(nil), "digitalkitchen.vrf.v1.VrfBeacon")
	proto.RegisterType((*AllowlistEntry)(nil), "digitalkitchen.vrf.v1.AllowlistEntry")
	proto.RegisterType((*VrfIdentity)(nil), "digitalkitchen.vrf.v1.VrfIdentity")
}

func init() { proto.RegisterFile("digitalkitchen/vrf/v1/vrf.proto", fileDescriptor_e758a8cd98a93fdd) }

var fileDescriptor_e758a8cd98a93fdd = []byte{
	// 470 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x92, 0x4f, 0x6f, 0xd3, 0x30,
	0x18, 0xc6, 0x9b, 0xad, 0x03, 0xd5, 0xe3, 0x5f, 0xad, 0x20, 0x85, 0x89, 0xa5, 0x63, 0x87, 0x69,
	0x97, 0x36, 0x0c, 0x6e, 0x9c, 0x58, 0xa5, 0x49, 0x20, 0x24, 0x84, 0x52, 0xd1, 0x03, 0x17, 0xe3,
	0xc4, 0x6e, 0x62, 0xcd, 0xb5, 0x23, 0xdb, 0x09, 0xcd, 0x87, 0x40, 0xe2, 0x1b, 0xc0, 0x87, 0xd8,
	0x87, 0xe0, 0x38, 0xed, 0xc4, 0x11, 0xb5, 0x17, 0x3e, 0x06, 0x8a, 0x9d, 0x68, 0x94, 0x4b, 0x92,
	0xf7, 0xf9, 0x3d, 0xd1, 0xf3, 0xe6, 0x89, 0xc1, 0x88, 0xb0, 0x8c, 0x19, 0xcc, 0x2f, 0x99, 0x49,
	0x73, 0x2a, 0xa2, 0x4a, 0x2d, 0xa2, 0xea, 0xac, 0xb9, 0x4d, 0x0a, 0x25, 0x8d, 0x84, 0x8f, 0xb7,
	0x0d, 0x93, 0x86, 0x54, 0x67, 0x07, 0x4f, 0x52, 0xa9, 0x97, 0x52, 0x23, 0x6b, 0x8a, 0xdc, 0xe0,
	0xde, 0x38, 0xf0, 0x33, 0x99, 0x49, 0xa7, 0x37, 0x4f, 0x4e, 0x3d, 0xfe, 0xee, 0x81, 0xc1, 0x5c,
	0x2d, 0xa6, 0x14, 0xa7, 0x52, 0xc0, 0x11, 0xd8, 0x27, 0x0a, 0x0b, 0x82, 0x94, 0x2c, 0x05, 0x09,
	0xbc, 0x23, 0xef, 0xb4, 0x1f, 0x03, 0x2b, 0xc5, 0x8d, 0x02, 0x43, 0x00, 0x9a, 0x41, 0x2e, 0x05,
	0xd5, 0x3a, 0xd8, 0x39, 0xf2, 0x4e, 0xef, 0xc5, 0xff, 0x28, 0xf0, 0x29, 0x18, 0x68, 0x96, 0x09,
	0x6c, 0x4a, 0x45, 0x83, 0x5d, 0x8b, 0x6f, 0x05, 0x38, 0x06, 0xb0, 0x50, 0xb4, 0x62, 0xb2, 0xd4,
	0xe8, 0xd6, 0xd6, 0xb7, 0xb6, 0x61, 0x47, 0x66, 0x1d, 0x78, 0xd5, 0xff, 0xf3, 0x63, 0xe4, 0x1d,
	0x7f, 0x06, 0x0f, 0xce, 0x39, 0x97, 0x5f, 0x38, 0xd3, 0xe6, 0x42, 0x18, 0x55, 0xc3, 0x17, 0xe0,
	0x2e, 0x26, 0x44, 0x35, 0x1b, 0x34, 0x1b, 0x0e, 0xa6, 0xc1, 0xcd, 0xd5, 0xd8, 0x6f, 0x3f, 0xf6,
	0xdc, 0x91, 0x99, 0x51, 0x4c, 0x64, 0x71, 0x67, 0x84, 0x3e, 0xd8, 0xe3, 0x38, 0xa1, 0xdc, 0xee,
	0x3c, 0x88, 0xdd, 0xd0, 0x26, 0x7c, 0xdd, 0x01, 0xfb, 0x73, 0xb5, 0x78, 0x4b, 0xa8, 0x30, 0xcc,
	0xd4, 0xf0, 0x3d, 0x18, 0x56, 0x98, 0x33, 0x82, 0x8d, 0x54, 0x68, 0x3b, 0xe9, 0xd9, 0xcd, 0xd5,
	0xf8, 0xb0, 0x4d, 0x9a, 0x77, 0x9e, 0xed, 0xc8, 0x47, 0xd5, 0x7f, 0x3a, 0x8c, 0x80, 0xef, 0x5a,
	0x4d, 0xb8, 0x46, 0x45, 0x99, 0x70, 0x96, 0xa2, 0x4b, 0x5a, 0xb7, 0xf5, 0x0d, 0x2d, 0x9b, 0x72,
	0xfd, 0xc1, 0x92, 0x77, 0xb4, 0x86, 0x87, 0x00, 0xa4, 0x39, 0x66, 0x02, 0xe5, 0x58, 0xe7, 0x5d,
	0x8d, 0x56, 0x79, 0x83, 0x75, 0x0e, 0x4f, 0xc0, 0x43, 0xdb, 0x1e, 0x47, 0xa5, 0x60, 0x2b, 0xa4,
	0x69, 0x6a, 0x3b, 0xdc, 0x8d, 0xef, 0x3b, 0xf9, 0xa3, 0x60, 0xab, 0x19, 0x4d, 0xe1, 0x73, 0xe0,
	0xb7, 0x3e, 0x45, 0x75, 0x8e, 0x15, 0x45, 0xb4, 0x90, 0x69, 0x1e, 0xec, 0xd9, 0xdf, 0x0a, 0x1d,
	0x8b, 0x1d, 0xba, 0x68, 0x88, 0xeb, 0x63, 0xfa, 0xfa, 0xe7, 0x3a, 0xf4, 0xae, 0xd7, 0xa1, 0xf7,
	0x7b, 0x1d, 0x7a, 0xdf, 0x36, 0x61, 0xef, 0x7a, 0x13, 0xf6, 0x7e, 0x6d, 0xc2, 0xde, 0xa7, 0x93,
	0x8c, 0x99, 0xbc, 0x4c, 0x26, 0xa9, 0x5c, 0x46, 0x24, 0x33, 0x5b, 0xc7, 0x73, 0x65, 0xaf, 0xa6,
	0x2e, 0xa8, 0x4e, 0xee, 0xd8, 0xc3, 0xf5, 0xf2, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2c, 0x7c,
	0xd1, 0x1e, 0xc7, 0x02, 0x00, 0x00,
}

func (this *VrfBeacon) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VrfBeacon)
	if !ok {
		that2, ok := that.(VrfBeacon)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DrandRound != that1.DrandRound {
		return false
	}
	if !bytes.Equal(this.Randomness, that1.Randomness) {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	if !bytes.Equal(this.PreviousSignature, that1.PreviousSignature) {
		return false
	}
	return true
}
func (this *AllowlistEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowlistEntry)
	if !ok {
		that2, ok := that.(AllowlistEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	return true
}
func (this *VrfIdentity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VrfIdentity)
	if !ok {
		that2, ok := that.(VrfIdentity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if !bytes.Equal(this.DrandBlsPublicKey, that1.DrandBlsPublicKey) {
		return false
	}
	if !bytes.Equal(this.ChainHash, that1.ChainHash) {
		return false
	}
	if this.SignalUnixSec != that1.SignalUnixSec {
		return false
	}
	if this.SignalReshareEpoch != that1.SignalReshareEpoch {
		return false
	}
	return true
}
func (m *VrfBeacon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VrfBeacon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VrfBeacon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PreviousSignature) > 0 {
		i -= len(m.PreviousSignature)
		copy(dAtA[i:], m.PreviousSignature)
		i = encodeVarintVrf(dAtA, i, uint64(len(m.PreviousSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintVrf(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Randomness) > 0 {
		i -= len(m.Randomness)
		copy(dAtA[i:], m.Randomness)
		i = encodeVarintVrf(dAtA, i, uint64(len(m.Randomness)))
		i--
		dAtA[i] = 0x12
	}
	if m.DrandRound != 0 {
		i = encodeVarintVrf(dAtA, i, uint64(m.DrandRound))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AllowlistEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowlistEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowlistEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintVrf(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintVrf(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VrfIdentity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VrfIdentity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VrfIdentity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignalReshareEpoch != 0 {
		i = encodeVarintVrf(dAtA, i, uint64(m.SignalReshareEpoch))
		i--
		dAtA[i] = 0x28
	}
	if m.SignalUnixSec != 0 {
		i = encodeVarintVrf(dAtA, i, uint64(m.SignalUnixSec))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ChainHash) > 0 {
		i -= len(m.ChainHash)
		copy(dAtA[i:], m.ChainHash)
		i = encodeVarintVrf(dAtA, i, uint64(len(m.ChainHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DrandBlsPublicKey) > 0 {
		i -= len(m.DrandBlsPublicKey)
		copy(dAtA[i:], m.DrandBlsPublicKey)
		i = encodeVarintVrf(dAtA, i, uint64(len(m.DrandBlsPublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintVrf(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintVrf(dAtA []byte, offset int, v uint64) int {
	offset -= sovVrf(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VrfBeacon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DrandRound != 0 {
		n += 1 + sovVrf(uint64(m.DrandRound))
	}
	l = len(m.Randomness)
	if l > 0 {
		n += 1 + l + sovVrf(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovVrf(uint64(l))
	}
	l = len(m.PreviousSignature)
	if l > 0 {
		n += 1 + l + sovVrf(uint64(l))
	}
	return n
}

func (m *AllowlistEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovVrf(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovVrf(uint64(l))
	}
	return n
}

func (m *VrfIdentity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovVrf(uint64(l))
	}
	l = len(m.DrandBlsPublicKey)
	if l > 0 {
		n += 1 + l + sovVrf(uint64(l))
	}
	l = len(m.ChainHash)
	if l > 0 {
		n += 1 + l + sovVrf(uint64(l))
	}
	if m.SignalUnixSec != 0 {
		n += 1 + sovVrf(uint64(m.SignalUnixSec))
	}
	if m.SignalReshareEpoch != 0 {
		n += 1 + sovVrf(uint64(m.SignalReshareEpoch))
	}
	return n
}

func sovVrf(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVrf(x uint64) (n int) {
	return sovVrf(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VrfBeacon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVrf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VrfBeacon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VrfBeacon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrandRound", wireType)
			}
			m.DrandRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrandRound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Randomness", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVrf
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVrf
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Randomness = append(m.Randomness[:0], dAtA[iNdEx:postIndex]...)
			if m.Randomness == nil {
				m.Randomness = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVrf
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVrf
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVrf
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVrf
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousSignature = append(m.PreviousSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreviousSignature == nil {
				m.PreviousSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVrf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVrf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowlistEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVrf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowlistEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowlistEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVrf
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVrf
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVrf
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVrf
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVrf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVrf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VrfIdentity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVrf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VrfIdentity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VrfIdentity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVrf
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVrf
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrandBlsPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVrf
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVrf
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrandBlsPublicKey = append(m.DrandBlsPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.DrandBlsPublicKey == nil {
				m.DrandBlsPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVrf
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVrf
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainHash = append(m.ChainHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ChainHash == nil {
				m.ChainHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignalUnixSec", wireType)
			}
			m.SignalUnixSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignalUnixSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignalReshareEpoch", wireType)
			}
			m.SignalReshareEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignalReshareEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVrf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVrf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVrf(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVrf
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVrf
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVrf
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVrf
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVrf
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVrf        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVrf          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVrf = fmt.Errorf("proto: unexpected end of group")
)
